# 理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题

通过阅读代码，我熟悉了ucore中内核级信号量的设计。每个信号量对应了一个整型值和一个等待队列：

    typedef struct {
        int value;
        wait_queue_t wait_queue;
    } semaphore_t;

信号量支持的基本操作包括`init`、`up`、`down`和`try_down`。其功能和设计分别如下：

* `init`：初始化信号量。这包括了初始化信号量中的`value`置和初始化等待队列。在实现中，`value`被赋上了一个给定的初始值，而`wait_queue`则是通过调用`wait_queue_init`完成了初始化（其实就是初始化了一个空的队列）
* `up`：释放锁。查看`wait_queue`中是否有正在等待锁的进程，如果有，则要将锁分配给它。具体地，需要将这个正在等待锁的进程从`wait_queue`中取出并唤醒。如果`wait_queue`为空，则现在多了一个空的锁，需要将`value`增一
* `down`：以阻塞的方式获取锁。检查`value`是否为正（是否有空闲的锁），如果为正则将其值减一，获取锁成功，函数可以立即返回。否则，将进程加入等待队列，设置其执行状态为`SLEEPING`，并记录其等待的资源为信号量，然后调用`schedule`函数将执行权交出（进入阻塞状态），等待需要的锁能够得到满足时被唤醒
* `try_down`：以非阻塞的方式获取锁。这个与`down`的区别就是无论当前能否获取到锁函数都会立即返回，不会进入等待状态。

实现中所有涉及`value`和`wait_queue`的操作，都通过禁用中断的方式（`local_intr_save`和`local_intr_restore`）保证了互斥。

如果要给用户态进程/线程提供信号量机制，就不能直接使用上面的实现方式，因为用户态进程无法直接控制中断的使能，也无法直接修改进程控制块中断中的信息。一种可能的实现方式是，仍然在内核中实现信号量，以系统调用的方式向应用程序提供接口。

使用信号量解决哲学家就餐问题的方法如下：

* 使用一个初始值为1的`mutex`信号量作为一个互斥锁，保证与哲学家状态有关的操作都是互斥的（也就是说在进行操作前申请锁，在完成操作后释放锁）。这样，不会出现一个进程改变哲学家状态改变到一半，被另外一个进程打断的情况，也就能够保证每次修改状态后得到的状态都是合法的，每次读取状态得到的信息也是准确的
* 为了让在饥饿状态但是没法拿到筷子的哲学家能够进入等待状态，为每个哲学家建立一个信号量`s[i]`，在进入饥饿状态时申请锁，在得到筷子时释放锁
* 哲学家进入饥饿状态时如果没能主动拿到筷子，就会因为申请锁`s[i]`不能立即得到满足而进入等待状态。为了使哲学家在可能拿到筷子时能够从等待状态退出，与其相邻的哲学家需要在放下筷子时检查其能否得到筷子，如果发现其能够得到筷子，则需要把刚放下的筷子主动递给他（即释放`s[i]`）

# 完成内核级条件变量和基于内核级条件变量的哲学家就餐问题

内核级条件变量可以基于信号量进行实现。按照注释里的说明，我实现了带有一个阻塞型条件变量的管态机制。

管态的数据结构如下：

    typedef struct monitor{
        semaphore_t mutex;      // the mutex lock for going into the routines in monitor, should be initialized to 1
        semaphore_t next;       // the next semaphore is used to down the signaling proc itself, and the other OR wakeuped waiting proc should wake up the sleeped signaling proc.
        int next_count;         // the number of of sleeped signaling proc
        condvar_t *cv;          // the condvars in monitor
    } monitor_t;

其中，`mutex`是对应管态的入口队列的信号量，`next`是对应管态的signaling队列的信号量（也就是那些通过signal将执行权交给等待条件变量的进程组成的队列），`next_count`记录了signaling队列的大小，`cv`是管态中条件变量的列表。

条件变量的数据结构如下：

    typedef struct condvar{
        semaphore_t sem;        // the sem semaphore  is used to down the waiting proc, and the signaling proc should up the waiting proc
        int count;              // the number of waiters on condvar
        monitor_t * owner;      // the owner(monitor) of this condvar
    } condvar_t;

其中，`sem`是对应条件变量等待队列的信号量，`count`记录了等待队列的大小，而`owner`是指向条件变量所属管程的指针。

管程/条件变量相关的操作有如下这些：

* `monitor_init`：初始化管程。这个函数根据参数中给定了管程条件变量的数量，创建初始化了管程中的条件变量
* `cond_signal`：当前在管程中执行的进程触发了某个条件变量。函数检查了这个信号变量的等待队列是否为空（`count`是否为0），如果不为空，则立即通过`up(sem)`激活条件变量等待队列中的某个进程，然后将当前的进程通过`down(next)`加入到signaling等待队列中，进入等待状态，将执行权让给刚刚从条件变量等待队列激活的进程（这里体现了所实现的信号量机制的阻塞性）
* `cond_wait`：当前在管程中执行的进程等待某个条件变量。函数在通过`down(sem)`将当前进程加入到等待队列进行等待之前，释放了一次管程的执行权。为了让先进入管程的进程能够优先执行，它首先检查了signaling队列（即`next`信号量），如果它不为空（`next_count != 0`），则激活signaling队列中的某个进程（`up(next)`），否则，释放`mutex`（`up(mutex)`，即激活当前进入管程的等待队列中的一个进程，或者，当该等待队列为空时，允许一个进程在未来某个时刻进入管程）

值得一提的是，这里每个条件变量的`sem`信号量以及管程中的`next`信号量都有如下特点：

* 初始值为0
* 有对应的记录等待队列大小的变量（`count`及`next_count`）
* 每次对它们进行`up`操作前，会先检查确保对应的等待队列大小是否为正

这三个特点导致它们：

* 信号量的值不会为正
* 每次`down`操作都会引起阻塞
* 每次`up`操作都会激活一个在等待队列中的进程
* 整个信号量的作用无异于一个等待队列。`up`相当于从等待队列中取出并激活一个进程，而`down`相当于将当前进程加入等待队列并开始等待

下面是这部分实验过程中我产生过的一些疑惑以及自己思考得出的一些结论：

* 为什么在signal的时候需要将当前进程`next`信号量等待队列中而不是直接`down(mutex)`？我其实觉得后一种方法应该也能work，只是可能没有遵循“先来后到”这样的公平性原则。在后一种方法中，由于signal而等待的进程A会被放入等待进入管程的进程队列中，而这个队列包含了那些在A之后申请进入管程的进程，也包括了其他由于signal而进行等待的进程。为了保证公平，我们需要将A恰好放在所有其他由于signal而进行等待的进程之后，其余还未进入管程的进程之前，每次激活从队列头部取出进程。可以发现，这样事实上就等价于两个单独的队列，只是在激活时signal队列优先级高于另一个队列，而这就是实验中注释提示的实现方式

由于条件变量机制完全可以通过信号量机制实现，我认为只需给用户态提供信号量机制的服务就可以允许用户态进程/线程使用条件变量机制。条件变量的实现中在信号量外包装的这一层完全可以放在用户态实现。

通过上面的分析，我认为条件变量机制可以不用信号量机制实现：

* `sem`和`next`信号量：只需要用等待队列就可以
* `mutex`信号量：一个普通的互斥锁，用一个等待队列+一位记录是否有进程运行在管道中就可以了

为了用条件变量机制解决哲学家就餐问题，我们可以将每个哲学家拿到筷子作为条件变量，然后：

* 在所有与哲学家状态相关的操作前获取`mutex`进入管程，在操作完成后退出管程。退出时需要判断`next`队列中是否有进程在等待，如果有则激活其中的一个，否则`up(mutex)`
* 在哲学家进入饥饿状态时检查能否立即得到筷子，如果不能，等待相应的条件变量
* 在哲学家用餐完毕时检查其邻居是否能够得到筷子，如果能，signal相应的条件变量

# 扩展：在ucore中实现简化的死锁和重入探测机制

# 扩展：参考Linux的RCU机制，在ucore中实现简化的RCU机制

# 与参考答案的比较

我的实现与参考实现没有重要的差异。唯一一处比较明显的差异是，参考实现在哲学家进入饥饿状态时，会直接调用`phi_test_condvar(i)`来查看是否能够得到筷子，而我的实现是通过判断`state_condvar[LEFT] == EATING || state_condvar[RIGHT] == EATING`。这个差异事实上不会导致任何后果，因为`phi_test_condvar`里面做的事情也是进行相同的判断。我当时之所以没有像参考实现这么写，大概是因为`phi_test_condvar`如果判断拿到了筷子，会在最后做一个signal操作，而这个signal操作在这里始终都是无效的，因为这个哲学家目前还在主动尝试得到筷子，没有进入等待条件变量的状态。

# 知识点

这次实验涉及的知识点包括：

* 计时器和等待队列机制。我在阅读代码的过程中了解了计时器以及等待队列这两种底层的调度机制的实现和使用方法。计时器机制在哲学家就餐的测试程序中通过sleep用到，而等待队列是信号量以及条件变量的实现基础
* 信号量和条件变量/管程。信号量的实现我是通过阅读代码学习到的，而条件变量是通过在实验中边阅读注释边根据自己的理解补充代码学习到的。我刚开始没有很好地理解条件变量的实现，有些被绕晕了，在参考了[维基百科的文章](https://en.wikipedia.org/wiki/Monitor_(synchronization))后获得了比较透彻的理解
* 经典的同步互斥问题。实验中我阅读了基于信号量的哲学家就餐问题解决方法，并自己尝试实现了基于条件变量的方法。通过实验我对信号量、条件变量的应用以及现实中的同步互斥问题都有了更加深入的理解

我认为比较重要但是实验未能覆盖的知识点包括：

* 读者写者问题。我觉得我们动手实现一下这个经典的问题还是有好处的（比如可以把实验里基于管程的哲学家就餐问题换成基于管程的读者写者问题），而且我认为读者写者应该是一个特别普遍、应用特别广泛的模型，在很多实际问题中应该都能够遇见